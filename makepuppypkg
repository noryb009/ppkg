#!/bin/bash -e
#
# Reads a PUPPYPKG file and creates a PET/SFS package
# 
# this script will read the PUPPYPKG, download any required files,
# extract them, build the program, then package it
# 

buildscript="PUPPYPKG"

### FUNCTIONS ###

# plain()
plain() {
 echo "  $1"
}

# msg()
msg() {
 echo "=> $1"
}

# msg2()
msg2() {
 echo "  -> $1"
}

# warning(message)
# prints an error, but doesn't exit
warning() {
 echo "Warning: $1"
}

# error(errorcode, message)
# prints an error
error() {
 if [ $# -eq 2 ]; then
  echo "Error: $2"
  exit $1
 else
  echo "Error: $1"
  exit 1
 fi
}

safeExit() {
 if [ "$#" -ne 0 ]; then
  error 1 "$@"
 else
  error 1 "Unknown error"
 fi
}

# inArray(needle, haystack[, haystack][, ...])
# returns 0 if needle is found, 1 if not
inArray() {
 needle="$1"
 shift
 while [[ $1 ]]; do
  [ "$needle" = "$1" ] && return 0 # found it
  shift
 done
 return 1 # didn't find it
}

# inOptionArray(needle, haystack[, haystack][, ...])
# returns '+' if needle is found and positive, '-' if found and negative, or '_' if not found
inOptionArray() {
 needle="$1"
 shift
 while [[ $1 ]]; do
  [[ "$needle" = "$1" || "+$needle" = "$1" ]] && echo "+" && return 0 # found it
  [[ "-$needle" = "$1" ]] && echo "-" && return 0 # found it
  shift
 done
 echo "_" # didn't find it
}

# inBuildOptions(needle) {
inBuildOptions() {
 local found="$(inOptionArray "$1" "${buildOptions[@]}")" # check options in makepuppypkg.conf
 [ "$found" = "_" ] && found="$(inOptionArray "$1" "${defaultBuildOptions[@]}")" # not found, use built in options
 echo "$found"
}

# inOptions(needle) {
inOptions() {
 local found="$(inOptionArray "$1" "${options[@]}")" # check options in build script
 [ "$found" = "_" ] && found="$(inOptionArray "$1" "${confOptions[@]}")" # not found, check makepuppypkg.conf settings
 [ "$found" = "_" ] && found="$(inOptionArray "$1" "${defaultOptions[@]}")" # not found, use built in options
 echo "$found"
}

# splitpartused(splitpart)
splitpartused() {
 if [[ "$loc_EXE" = "$1" || "$loc_DEV" = "$1" || "$loc_DOC" = "$1" || "$loc_NLS" = "$1" ]]; then
  return 0 # is used
 fi
 return 1 # is not used
}

# islocal(file)
# 0 if local, 1 if not
islocal() {
 if [[ "$1" == *://* ]]; then
  return 1 # remote
 fi
 return 0 # local
}

# getRealPath(path)
getRealPath() {
 if [ -d "$1" ]; then
 (
  cd "$1"
  pwd -P
 )
 else
  echo "$1"
 fi
}

# getlocalfilename(file)
getlocalfilename() {
 echo "${1##*/}"
}

# getabslocalfilename(file)
getabslocalfilename() {
 local file="$(getlocalfilename "$1")"
 if [ -f "$startdir/$file" ]; then
  echo "$startdir/$file"
 elif [ -f "$srcdest/$file" ]; then
  echo "$srcdest/$file"
 elif [ -f "$srcdir/$file" ]; then
  echo "$srcdir/$file"
 else
  return 1 # error: couldn't find
 fi
 return 0 # found it
}

# getremotetype(file)
getremotetype() {
 echo "${1%%://*}"
}

# getmd5(file)
getmd5() {
 local md5="$(md5sum "$1")"
 echo "${md5%% *}"
}

generateMD5() {
 local localname
 local output="md5sums=("
 for file in "${sources[@]}"; do
  if localname="$(getabslocalfilename "$file")"; then # local or already downloaded
   output="$output '$(getmd5 "$localname")'"
  else
   error 1 "Could not find $(getlocalfilename "$file")"
  fi
 done
 output="$output )"
 echo "$output"
}

# checkmd5(file, md5sum)
# file is the path to the file
# md5sum is the number in the md5sum array to check the md5sum with
checkmd5() {
 [ $skipMD5Check -eq 1 ] && return 0 # skip MD5 check command line option
 [ $2 -gt ${#md5sums[@]} ] && return 1 # spot in array doesn't exist
 if [ "${md5sums[$2]}" != "$(getmd5 "$1")" ]; then
  error 1 "$file does not match it's checksum"
 fi
 return 0
}

createPbuild() {
 msg "Making pbuild..."
 local tempSourceDir="$(mktemp -d "$startdir/pBuild.XXXXXXXXXX")"
 mkdir "$tempSourceDir/$pkgname/"
 
 # add PUPPYPKG
 msg2 "Adding $buildscript..."
 ln -s "$startdir/$buildFile" "$tempSourceDir/$pkgname/$buildscript"
 
 # add files
 local file
 for file in "${sources[@]}"; do
  if islocal "$file"; then
   
   if getabslocalfilename "$file" > /dev/null; then
    msg2 "Adding ${file}..."
    file="$(getabslocalfilename "$file")"
    ln -s "$file" "$tempSourceDir/$pkgname/"
   else
    rm -rf "$tempSourceDir"
    error 1 "Could not find file '$file'"
   fi
  fi
 done
 
 # output
 file="$startdir/$pkgname-$pkgver-$pkgrev.pbuild.tar.gz"
 [ -f "$file" ] && rm -f "$file"
 (
  cd "$tempSourceDir"
  tar czhf "$file" --group=root --owner=root "$pkgname"
 )
 
 rm -rf "$tempSourceDir"
 
 msg "Pbuild created"
}

compileOnePbuild() {
 local packageName="${1##*/}"
 packageName="${1%-*-*}"
 msg "Compiling $packageName"
 
 local compileDir="$startdir/${packageName}"
 [ -d "$compileDir" ] && rm -rf "$compileDir"
 mkdir "$compileDir"
 
 local ret
 local currDir="$PWD"
 
 tar xzf "$1" --strip-components=1 -C "$compileDir"
 
 thisScript="$(readlink -f "$0")" # if user started script with path specified (/usr/bin/makepuppypkg), use it
 if [ ! -e "$thisScript" ]; then # no path
  if ! which "$0" &> /dev/null; then
   error 1 "Could not find location of 'makepuppypkg'"
  fi
  thisScript="$(which "$0")"
 fi
 cd "$compileDir"
 "$thisScript" --ignore-pbuild --force-o "$outDir" "${args[@]}"
 cd "$currDir"
 
 [ $2 -eq 2 ] && rm -rf "$compileDir"
 return 0
}

getSources() {
 msg "Getting sources..."
 
 cd "$srcdest"
 local file
 local fileNumber=-1
 local localname
 local connectType
 local ret
 
 for file in "${sources[@]}"; do
  fileNumber=$((fileNumber+1)) # next file number
  if localname="$(getabslocalfilename "$file")"; then # local or already downloaded
   checkmd5 "$localname" $fileNumber # check md5 sum
  else # file doesn't exist
   if islocal "$file"; then # local 
    error 1 "Could not find $file"
   else # remote
    localname="$srcdest/$(getlocalfilename "$file")"
    connectType="$(getremotetype "$file")"
    
    case "$connectType" in
     http) 
      wget -c -t 3 --waitretry=3 -O "${localname}.part" "$file"
      ret=$? ;;
     https) 
      wget -c -t 3 --waitretry=3 --no-check-certificate -O "${localname}.part" "$file"
      ret=$? ;;
     ftp)
      wget -c --passive-ftp -t 3 --waitretry=3 -O "${localname}.part" "$file"
      ret=$? ;;
     *) error 1 "Could not download $file: unknown protocol" ;;
    esac
    if [ $ret -ne 0 ]; then
     error 1 "Could not download $file"
    fi
    checkmd5 "${localname}.part" $fileNumber # check md5 sum
    mv "${localname}.part" "$localname"
   fi
  fi
 done
 
 if [ $genMD5 -eq 1 ]; then # if generating MD5 sums
  msg "Appending source MD5 sums to $buildFile..."
  echo "$(generateMD5)" >> "$buildFile"
  exit 0
 fi
 
 if [ $downloadOnly -eq 1 ]; then
  msg "Sources have been downloaded"
  exit 0
 fi
}

extractSources() {
 msg "Extracting sources..."
 cd "$srcdir"
 local file
 local ret
 local extractcmd
 local localname
 for file in "${sources[@]}"; do
  localname="$(getlocalfilename "$file")"
  
  if ! getabslocalfilename "$localname" > /dev/null; then
   error 1 "Could not find $localname"
  fi
  
  if [[ ! -e "$srcdir/$localname" ]]; then
   ln -s "$(getabslocalfilename "$localname")" "$srcdir"
  fi
  # check if in noextract array
  if inArray "$file" "${noextract[@]}"; then
   continue # skip
  fi
  
  local decompress
  case "$file" in
   *tar) decompress="" ;;
   *tar.gz) decompress="z" ;;
   *tar.bz2) decompress="j" ;;
   *tar.xz) decompress="J" ;;
   *) continue
  esac
  
  tar x${decompress}f "$localname" &> /dev/null
  if [ $? -ne 0 ]; then
   error 1 "Error extracting $localname"
  fi
 done
 
 if [ $extractOnly -eq 1 ]; then
  msg "Sources have been downloaded and extracted"
  exit 0
 fi
}

build() {
 msg2 "No build function found"
 return 0
}

check() {
 msg2 "No check function found"
 return 0
}

enterFakeroot() {
 msg "Entering fakeroot..."
 cd "$startdir"
 fakeroot -- "$0" --inside-fake-root "${args[@]}"
 local ret=$?
 msg "Exiting fakeroot"
 return $ret
}

package() {
 msg2 "No package function found"
 return 0
}

# mvSplit(fromSplit, toSplit, file[, file][, file] [...])
# function to use in afterSplit() to fix split file locations
mvSplit() {
 if [ $# -lt 3 ]; then
  error 1 "Error in $buildscript->afterSplit(): mvSplit() needs at least one file to move"
 fi
 
 local from="$1"
 shift
 local to="$1"
 shift
 
 [[ "$from" = "EXE" || "$from" = "DEV" || "$from" = "DOC" || "$from" = "NLS" ]] || error 1 "Error in $buildscript->afterSplit(): invalid 'from' location, received '$from'"
 [[ "$to" = "EXE" || "$to" = "DEV" || "$to" = "DOC" || "$to" = "NLS" ]] || error 1 "Error in $buildscript->afterSplit(): invalid 'to' location, received '$to'"
 
 local fromLoc="$(eval echo '$'loc_$from)"
 local toLoc="$(eval echo '$'loc_$to)"
 
 [ $fromLoc = $toLoc ] && return 0 # don't move if in same place
 
 while [[ $1 ]]; do
  file="${1#/}" # remove / from start
  shift
  if [ ! -e "${pkgdir}-${fromLoc}/$file" ]; then
   warning "'${pkgdir}-${fromLoc}/$file' does not exist, cannot be moved by mvSplit()"
   continue
  fi
  [ ! -d "${pkgdir}-${toLoc}/$(dirname "$file")" ] && mkdir -p "${pkgdir}-${toLoc}/$(dirname "$file")"
  mv -f "${pkgdir}-${fromLoc}/$file" "${pkgdir}-${toLoc}/$file"
 done
}

afterSplit() {
 msg2 "No afterSplit function found"
 return 0
}

# runFunction(functionName)
# run a function
runFunction() {
 cd "$srcdir"
 
 local shellopts=$(shopt -p) # back up options
 export CFLAGS CXXFLAGS LDFLAGS MAKEFLAGS CHOST # export flags
 
 if type -p "$1" > /dev/null; then
  $1 # run function
 else
  warning "Could not find function '$1' in $buildFile"
 fi
 
 eval "$shellopts" # restore options
}

runBuild() {
 msg "Building..."
 runFunction "build"
 
 if [ $buildOnly -eq 1 ]; then
  msg "The package has been built"
  exit 0
 fi
}

runCheck() {
 msg "Checking..."
 runFunction "check"
}

runPackage() {
 msg "Packaging..."
 if [ $MULTIPKG -eq 0 ]; then # not multi package
  runFunction "package"
 else
  runFunction "package_$1"
 fi
}

runAfterSplit() {
 [ $skipSplitting = 1 ] && return 0
 msg "Fixing split..."
 if [ $MULTIPKG -eq 0 ]; then # not multi package
  runFunction "afterSplit"
 else
  runFunction "afterSplit_$1"
 fi
}

strip() {
 strippkg "$pkgdir" &> /dev/null
}

runPackageOps() {
 msg "Running package options..."
 if [ "$(inOptions strip)" = "+" ]; then
  msg2 "Shrinking binaries and libraries by removing unneeded symbols..."
  strip
 fi
}

checkpkg() {
 msg "Checking package..."
 # from arch's makepkg
 if find "${pkgdir}" -type f -print0 | xargs -0  grep -q -m 1 -I "${srcdir}" ; then
  warning "Package contains reference(s) to $srcdir"
 fi
 if find "${pkgdir}" -type f -print0 | xargs -0  grep -q -m 1 -I "${pkgdir}" ; then
  warning "Package contains reference(s) to $pkgdir"
 fi
}

split() {
 msg "Spliting package..."
 
 if [ $forceSplit -eq 1 ]; then # split from commandline
  skipSplitting=0
 elif [ $forceSplit -eq 0 ]; then # don't split from commandline
  skipSplitting=1
 elif [ "$(inOptions split)" = "+" ]; then # check options
  skipSplitting=0
 else
  skipSplitting=1
 fi
 
 local part
 for part in "${pkgParts[@]}"; do
  [ -d "${pkgdir}_${part}" ] && rm -rf "${pkgdir}_${part}" # delete split folder
  [ -d "$pkgdir-$part" ] && rm -rf "$pkgdir-$part"
  [ $skipSplitting -eq 1 ] && continue
  mkdir -p "${pkgdir}-${part}"
  [ "${part}" != "EXE" ] && mkdir -p "${pkgdir}_${part}"
 done
 
 if [ $skipSplitting -eq 1 ]; then
  msg2 "Skipping splitting"
  cp -r "$pkgdir" "${pkgdir}-EXE" # TODO: just move?
  return 0
 fi
 
 # back up pkgdir
 cp -r "$pkgdir" "${pkgdir}-backup" # TODO: is backup needed?
 
 # split $pkgdir
 splitpkg "$(basename "$pkgdir")" "$pkgdir" &> /dev/null
 
 # restore backup
 mv -f "$pkgdir" "${pkgdir}_EXE"
 
 mv -f "${pkgdir}-backup" "$pkgdir"
 
 shopt -s extglob
 
 # redirect output
 local locArray=( "$loc_EXE"  "$loc_DEV"  "$loc_DOC"  "$loc_NLS" )
 local i
 for (( i=0; i<4; i++ )); do
  if [[ "${locArray[i]}" != "" && "$(ls -A "${pkgdir}_${pkgParts[i]}")" ]]; then
   cp -r "${pkgdir}_${pkgParts[i]}/"* "${pkgdir}-${locArray[i]}/"
   [ -f "$startdir/${pkgname}-pinstall.sh_${pkgParts[i]}" ] && cat "$startdir/${pkgname}-pinstall.sh_${pkgParts[i]}" >> "${pkgdir}-${locArray[i]}/pinstall.sh" && chmod +x "${pkgdir}-${locArray[i]}/pinstall.sh"
   [ -f "$startdir/${pkgname}-puninstall.sh_${pkgParts[i]}" ] && cat "$startdir/${pkgname}-puninstall.sh_${pkgParts[i]}" >> "${pkgdir}-${locArray[i]}/puninstall.sh" && chmod +x "${pkgdir}-${locArray[i]}/puninstall.sh"
  fi
 done
 
 shopt -u extglob
 
 rm -rf "${pkgdir}_"{EXE,DEV,DOC,NLS}
}

# getPETpetspecs()
# get the pet.specs entry for a PET package
getPETpetspecs() {
 local pkgsize="$(du -s -k "$pkgdir/" | cut -f 1)"
 
 local pkgdeps
 if splitpartused "EXE" && [[ "$pkgsplit" != "" && "$(ls -A "$pkgdir-EXE")" ]]; then # DOC, DEV or NLS needs EXE package if it exists
  pkgdeps="+$pkgname"
 fi
 
 local onedep
 local onedeppkg
 local onedepname
 for onedep in "${deps[@]}"; do
  if [[ "$onedep" =~ (EXE|DOC|DEV|NLS):* ]]; then # package split specified
   onedeppkg="${onedep%%:*}"
   onedepname="${onedep#*:}"
  else # default to EXE
   onedeppkg="EXE"
   onedepname="$onedep"
  fi
  
  [ "$(eval echo '$'loc_$onedeppkg)" != "$part" ] && continue # not in this package
  
  [ "$(echo "$pkgdeps" | egrep "(^|,)\+${onedepname}(<|=|>|,|$)")" != "" ] && continue # already in deps
  
  [ "$pkgdeps" != "" ] && pkgdeps="${pkgdeps},"
  pkgdeps="${pkgdeps}+${onedepname}"
 done
 
 # replace < with &lt, > with &gt, etc.
 pkgdeps="$(echo "$pkgdeps" | sed -e 's/<=/\&le/g' -e 's/>=/\&ge/g' -e 's/</\&lt/g' -e 's/>/\&gt/g' -e 's/=/\&eq/g')"
 
 if [ "${arch[0]}" = "any" ]; then
  echo "${pkgfullname}|${pkgname}${pkgsplit}|$pkgver|${pkgrev}-any|$pkgcategory|${pkgsize}K||${pkgfullname}.pet|${pkgdeps}|${pkgdesc}|"
 else
  echo "${pkgfullname}|${pkgname}${pkgsplit}|$pkgver|${pkgrev}-${CARCH}|$pkgcategory|${pkgsize}K||${pkgfullname}.pet|${pkgdeps}|${pkgdesc}|"
 fi
}

compresstopkg() {
 msg "Compressing package(s)..."
 cd "$startdir"
 local file
 local ret
 
 local part
 for part in "${pkgParts[@]}"; do
  if [ "$part" != "EXE" ]; then
   pkgsplit="_${part}"
  else
   pkgsplit=""
  fi
  
  if inArray "any" "${arch[@]}"; then
   pkgfullname="${pkgname}${pkgsplit}-$pkgver-$pkgrev-any" # get package name (with split)
  else
   pkgfullname="${pkgname}${pkgsplit}-$pkgver-$pkgrev-$CARCH" # get package name (with split)
  fi
  
  # delete old packages
  [ $makePetPkg -eq 1 ] && rm -f "$outDir/${pkgfullname}.pet" 
  [ $makeSfsPkg -eq 1 ] && rm -f "$outDir/${pkgfullname}.sfs"
  
  if [ $skipSplitting -eq 0 ]; then # not skipping
   if ! splitpartused "$part"; then # find if package part not used
    continue
   fi
   [ "$(ls -A "$pkgdir-${part}")" ] || continue # skip if package folder is empty
  else # skipping splitting
   [ "$part" != "EXE" ] && continue
  fi
  
  # compress
  if [ $makePetPkg -eq 1 ]; then # PET package
   msg2 "Creating PET package(s)..."
   [ -e "$pkgfullname" ] && rm -rf "$pkgfullname"
   mv -f "$pkgdir-${part}" "$pkgfullname"
   echo "$(getPETpetspecs)" > "$pkgfullname/pet.specs"
   tar c "${pkgfullname}" | gzip --best > "$outDir/${pkgfullname}.pet"
   ret=$?
   rm -rf "$pkgfullname/pet.specs"
   mv -f "$pkgfullname" "$pkgdir-${part}"
   
   if [ $ret -ne 0 ]; then
    error 1 "Could not compress the PET package"
   fi
   echo -n "$(getmd5 "$outDir/${pkgfullname}.pet")" >> "$outDir/${pkgfullname}.pet"
  fi
  
  if [ $makeSfsPkg -eq 1 ]; then # SFS package
   msg2 "Creating SFS package(s)..."
   mksquashfs "$pkgdir-${part}" "$outDir/${pkgfullname}.sfs" $sfsOptions # note: $sfsOptions should not have quotes
  fi
 done
}

# cleanup(cleanSrc, doNotMessage)
cleanup() {
 local goingToClean
 if [ $forceCleanup -eq 1 ]; then # force clean from command line
  goingToClean=1
 elif [ $forceCleanup -eq 0 ]; then # force no clean from command line
  goingToClean=0
 elif [ "$(inBuildOptions cleanup)" != "-" ]; then # check build options
  goingToClean=1
 else
  goingToClean=0
 fi
 
 [ $goingToClean -eq 0 ] && return 0 # skip cleaning
 
 [[ $# -gt 1 && $2 -eq 1 ]] || msg "Cleaning up..."
 local folders=( "$pkgdir" "${pkgdir}-EXE" "${pkgdir}-DEV" "${pkgdir}-DOC" "${pkgdir}-NLS" )
 [[ "$1" != "" && $1 -eq 1 ]] && folders+=( "$srcdir" )
 local folder
 for folder in "${folders[@]}" ; do
  [ -d "$folder" ] && rm -rf "$folder"
 done
 return 0
}

runSinglePackage() {
 runPackage
 runPackageOps
 split
 runAfterSplit
 checkpkg
 compresstopkg
 cleanup 1
}

backupPkgVars() {
 local var
 local backupVar
 for var in "${multipkgBackupVars[@]}"; do
  backupVar="${var}_bak"
  eval "${backupVar}=(\"\${$var[@]}\")"
 done
}

restorePkgVars() {
 local var
 local backupVar
 for var in "${multipkgBackupVars[@]}"; do
  backupVar="${var}_bak"
  eval "${var}=(\"\${$backupVar[@]}\")"
 done
}

runMultiPackage() {
 # back up package vars
 local _pkgname=("${pkgname[@]}")
 local _pkgdir="$pkgdir"
 
 for pkgname in "${_pkgname[@]}"; do
  msg "Packaging $pkgname..."
  
  pkgdir="$_pkgdir/$pkgname"
  mkdir -p "$pkgdir"
  backupPkgVars
  
  runPackage "$pkgname"
  runPackageOps
  split
  runAfterSplit
  checkpkg
  compresstopkg
  cleanup 0
  
  restorePkgVars
 done
 pkgname="${_pkgname[@]}"
 pkgdir="$_pkgdir"
 
 cleanup 1 1 # clean everything, don't output message
}

help() {
 cat << HERE_EOF
makepuppypkg [options]
Compiles a program into a package using '$buildscript'

Options:
      --pet      | create a PET package
      --sfs      | create an SFS package
  
  -a, --no-arch  | don't check if your architecture is in arch()
  -b <file>      | use <file> instead of '$buildscript' to create the package
  -c, --clean-up | clean up build files and folders
  -C, --no-clean-up| don't clean up build files and folders
  -g, --generate | generate md5 sums of the source files
      --skip-md5 | skip source md5sum checks
  -o <path>      | save package files to <path>
  -p, --pbuild <file>, <file>, ... | compile pbuild files
      --pbuild-clean <file>, ... | compile pbuild files, then cleanup (warning: 
                   deletes sources if srcdir is not set in makepuppypkg.conf)
  -P, --make-pbuild| compress '$buildscript' and local source files to a pbuild file
  -u, --as-user  | run as user
  
  -d, --download | download sources, then exit
  -e, --extract  | download and extract sources, then exit
  -B, --build    | build package, then exit
  -s, --split    | split package into EXE, DEV, DOC and NLS
  -S, --no-split | don't split package into EXE, DEV, DOC and NLS
  
  -h, --help     | display this help
HERE_EOF
}

### END FUNCTIONS ###

### VARIABLES ###
#default flags
args=("$@") # backup arguments for fakeroot

MAKEFLAGS="-j$(($(grep -c ^processor /proc/cpuinfo)+1))"
LDFLAGS="-Wl,-O1,--sort-common,--as-needed,-z,relro,--hash-style=gnu"
CARCH="$(uname -m)"
case "$CARCH" in
 i?86)
  #CARCH="$(uname -m)"
  CHOST="${CARCH}-puppy-linux-gnu"
  CFLAGS="-march=${CARCH} -mtune=generic -pipe -fstack-protector --param=ssp-buffer-size=4 -D_FORTIFY_SOURCE=2"
  CXXFLAGS="${CFLAGS}" ;;
 x86_64)
  #CARCH="x86_64"
  CHOST="x86_64-puppy-linux-gnu"
  CFLAGS="-march=x86-64 -mtune=generic -Os -pipe -fstack-protector --param=ssp-buffer-size=4 -D_FORTIFY_SOURCE=2"
  CXXFLAGS="${CFLAGS}" ;;
esac

loc_EXE='EXE'
loc_DEV='DEV'
loc_DOC='DOC'
loc_NLS='NLS'

startdir="$PWD"
srcdest="$startdir"
srcdir="$startdir/src"
pkgdir="$startdir/pkg"
outDir="$startdir"

# error catching
trap 'safeExit "Received TERM signal, exiting..."' TERM
trap 'safeExit "Received HUP signal, exiting..."' HUP
trap 'safeExit "Received QUIT signal, exiting..."' QUIT
trap 'safeExit "Received unknown error, exiting..."' ERR
trap 'safeExit "Aborted by user, exiting..."' INT

# include makepuppypkg.conf
foundConf=0
[ -f /etc/makepuppypkg.conf ] && . /etc/makepuppypkg.conf && foundConf=1
[ -f ~/.makepuppypkg.conf ] && . ~/.makepuppypkg.conf && foundConf=1

if [ $foundConf -eq 0 ]; then # didn't find makepuppypkg.conf
 error 1 "Could not find makepuppypkg.conf"
fi

# need CARCH and CHOST
[[ "$CARCH" = "" ]] && echo "Could not find CARCH. Please define it in makepuppypkg.conf"
[[ "$CHOST" = "" ]] && echo "Could not find CHOST. Please define it in makepuppypkg.conf"

pkgParts=('EXE' 'DEV' 'DOC' 'NLS')
multipkgBackupVars=('loc_EXE' 'loc_DEV' 'loc_DOC' 'loc_NLS' 'pkgver' 'pkgrev' 'pkgdesc' 'arch' 'deps' 'options' 'groups' 'provides' 'conflicts' 'replaces')
defaultBuildOptions=(+cleanup +fakeroot)
defaultOptions=(+strip +split)

##default buildoptions
#BUILDOPTIONS=(-deletesrcs deletesrc deletepkg)
#OPTIONS=(+strip)

# command line options

makePetPkg=0
makeSfsPkg=0

buildFile="$buildscript"
compilePbuild=0
ignoreCompilePbuild=0
skipArchCheck=0
skipMD5Check=0
genMD5=0
forceCleanup=-1 # use whatever is in options array
runAsUser=0
inFakeRoot=0
makePbuild=0
forceOut=0

downloadOnly=0
extractOnly=0
buildOnly=0
forceSplit=-1

### END VARIABLES ###

### MAIN CODE ###

while [[ $1 ]]; do
 case "$1" in
  --pet) makePetPkg=1 ;;
  --sfs) makeSfsPkg=1 ;;
  
  -a|--no-arch) skipArchCheck=1 ;;
  -b) shift; buildFile="$1" ;;
  -c|--clean-up) forceCleanup=1 ;;
  -C|--no-clean-up) forceCleanup=0 ;;
  -g|--generate) genMD5=1; skipMD5Check=1 ;; # also skip md5check
  -o) shift; [ $forceOut -eq 0 ] && outDir="$1" ;;
  -p|--pbuild) if [ $ignoreCompilePbuild -eq 0 ]; then compilePbuild=1; shift; fi; break ;;
  --pbuild-clean) if [ $ignoreCompilePbuild -eq 0 ]; then compilePbuild=2; shift; fi; break ;;
  -P|--make-pbuild) makePbuild=1 ;;
  --skip-md5) skipMD5Check=1 ;;
  -u|--as-user) runAsUser=1 ;;
  
  -d|--download) downloadOnly=1 ;;
  -e|--extract) extractOnly=1 ;;
  -B|--build) buildOnly=1 ;;
  -s|--split) forceSplit=1 ;;
  -S|--no-split) forceSplit=0 ;;
  
  --ignore-pbuild) ignoreCompilePbuild=1 ;;
  --inside-fake-root) inFakeRoot=1 ;;
  --force-o) forceOut=1; shift; outDir="$1" ;;
  
  -h|--help) help; exit 0 ;;
  
  *) error 1 "Unknown argument: $1"
 esac
 shift
done

# check for needed programs
if [ "$(inBuildOptions fakeroot)" = "+" ]; then
 if ! type -p fakeroot > /dev/null; then
  error 1 "You do not have 'fakeroot'. Please install it or disable it in makepuppypkg.conf"
 fi
fi

if [ $makeSfsPkg -eq 1 ]; then
 if ! type -p mksquashfs > /dev/null; then
  error 1 "You do not have 'mksquashfs'. Please install it or don't use the '--sfs' flag"
 fi
fi

# check for root privileges
if [ $runAsUser -eq 0 ]; then
 if [[ $EUID -ne 0 && "$(inBuildOptions fakeroot)" = "-" ]]; then
  error 1 "You do not have root privileges. Use the -u or --as-user options to run as a user, or enable 'fakeroot' in makepuppypkg.conf"
 fi
else
 if [[ $inFakeRoot -eq 0 && $EUID -eq 0 ]]; then
  warning "You shouldn't use the -u or --as-user flags while being root"
  sleep 2
 fi
fi

# check if building any packages
if [[ $makePetPkg -eq 0 && $makeSfsPkg -eq 0 && $downloadOnly -eq 0 && $extractOnly -eq 0 && $buildOnly -eq 0 && $genMD5 -eq 0 ]]; then
 error 1 "You are not creating any packages. Please use the --pet and/or --sfs options on the command line"
fi

# check for being able to write to folders
[ ! -d "$srcdest" ] && mkdir -p "$srcdest"
srcdest="$(getRealPath "$srcdest")"
[ ! -w "$srcdest" ] && error 1 "You cannot write to the source storage folder, '$srcdest'"

[ ! -d "$outDir" ] && mkdir -p "$outDir";
outDir="$(getRealPath "$outDir")"
[ ! -w "$outDir" ] && error 1 "You cannot write to the package output folder, '$outDir'"

# if compiling pbuilds
if [ $compilePbuild -ne 0 ]; then
 while [[ $1 ]]; do
  compileOnePbuild "$1" "$compilePbuild"
  shift
 done
 msg "All pBuilds have been compiled"
 exit 0
fi

# check for buildscript
if [ ! -f "$buildFile" ]; then
 error 1 "Could not find '$buildFile'"
fi

. "./$buildFile"

# check if making build tarball
if [ $makePbuild -eq 1 ]; then
 createPbuild
 exit 0
fi

# check for matching arch
if [ $skipArchCheck -eq 0 ]; then # not skipping check
 if ! inArray "$CARCH" "${arch[@]}" && ! inArray "any" "${arch[@]}" ; then
  error 1 "This package could not be built for your architecture, $CARCH"
 fi
fi

if [ ${#pkgname[@]} -gt 1 ]; then
 MULTIPKG=1
else
 MULTIPKG=0
fi

if [ $inFakeRoot -eq 0 ]; then
 [ -d "$srcdir" ] && rm -rf "$srcdir"
 mkdir -p "$srcdir"
 
 getSources
 
 extractSources
 
 runBuild
 runCheck
 
 if [[ $EUID -ne 0 && "$(inBuildOptions fakeroot)" = "+" ]]; then # not root, using fakeroot
  enterFakeroot
  exit $?
 fi
fi

[[ -d "$pkgdir" ]] && rm -rf "$pkgdir"
mkdir -p "$pkgdir"
if [ $MULTIPKG -eq 0 ]; then
 runSinglePackage
else
 runMultiPackage
fi

exit 0

### END MAIN CODE ###
