#!/bin/sh
#
# Reads a PUPPYPKG file and creates a PET package
# 
# There should be one or more files in a build folder:
# bash/
#   - PUPPYPKG
#   - pinstall.sh
# 
# this script will read the PUPPYPKG, download any required files,
# extract them, build the program, then package it
# 
# At the end of this script, the build directory should look like:
# bash/
#   - PUPPYPKG
#   - pinstall.sh
#   - src/
#     - *source files*
#   - pkg/
#     - *compiled files*
#   - bash-4.0-1-i686.pet

buildscript="PUPPYPKG"

### FUNCTIONS ###

# error(errorcode, message)
# prints an error
error() {
 echo "Error: $2"
 exit $1
}

# inarray(needle, haystack[, haystack][, ...])
# returns 0 if needle is found, 1 if not
inarray() {
 needle="$1"
 shift
 while [[ $1 ]]; do
  [ "$needle" = "$1" ] && return 0 # found it
  shift
 done
 return 1 # didn't find it
}

# splitpartused(splitpart)
splitpartused() {
 if [[ "$loc_EXE" = "$1" || "$loc_DEV" = "$1" || "$loc_DOC" = "$1" || "$loc_NLS" = "$1" ]]; then
  return 0 # is used
 fi
 return 1 # is not used
}

# islocal(file)
# 0 if local, 1 if not
islocal() {
 if [[ "$1" == *://* ]]; then
  return 1 # remote
 fi
 return 0 # local
}

# error(file)
getlocalfilename() {
 echo "${1##*/}"
}

# getabslocalfilename(file)
getabslocalfilename() {
 local file="$(getlocalfilename "$1")"
 if [ -f "$startdir/$file" ]; then
  echo "$startdir/$file"
 elif [ -f "$srcdir/$file" ]; then
  echo "$srcdir/$file"
 else
  return 1 # error: couldn't find
 fi
 return 0 # found it
}

# getremotetype(file)
getremotetype() {
 echo "${1%%://*}"
}

# getmd5(file)
getmd5() {
 local md5="$(md5sum "$1")"
 echo "${md5%% *}"
}

generatemd5() {
 local localname
 local output="md5sums=("
 for file in "${sources[@]}"; do
  if localname="$(getabslocalfilename "$file")"; then # local or already downloaded
   output="$output '$(getmd5 "$localname")'"
  else
   error 1 "Could not find $(getlocalfilename "$file")"
  fi
 done
 output="$output )"
 echo "$output"
}

# checkmd5(file, md5sum)
checkmd5() {
 if [ "$2" != "$(getmd5 "$1")" ]; then # | cut -f 1 -d \ " ]; then
  error 1 "$file does not match it's checksum"
 fi
 return 0
}

getSources() {
 cd "$startdir"
 local file
 local fileNumber=-1
 local localname
 local connectType
 local ret
 
 for file in "${sources[$@]}"; do
  ((fileNumber++)) # next file number
  if localname="$(getabslocalfilename "$file")"; then # local or already downloaded
   # link file
   if [ ! -f "$srcdir/$(getlocalfilename "$file")" ]; then
    ln -s "$localname" "$srcdir"
   fi
   checkmd5 "$localname" "${md5sums[$fileNumber]}" # check md5 sum
  else # file doesn't exist
   if islocal "$file"; then # local 
    error 1 "Could not find $file"
   else # remote
    localname="$(getlocalfilename "$file")"
    connectType="$(getremotetype "$file")"
    
    case "$connectType" in
     http) 
      wget -c -t 3 --waitretry=3 -O "${localname}.part" "$file"
      ret=$? ;;
     https) 
      wget -c -t 3 --waitretry=3 --no-check-certificate -O "${localname}.part" "$file"
      ret=$? ;;
     ftp)
      wget -c --passive-ftp -t 3 --waitretry=3 -O "${localname}.part" "$file"
      ret=$? ;;
     *) error 1 "Could not download $file: unknown protocol"
    esac
    if [ $ret -ne 0 ]; then
     error 1 "Could not download $file"
    fi
    checkmd5 "${localname}.part" "${md5sums[$fileNumber]}" # check md5 sum
    mv "${localname}.part" "$localname"
    ln -s "$localname" "$srcdir"
   fi
  fi
 done
}

extractSources() {
 cd "$srcdir"
 local file
 local ret
 local extractcmd
 local localname
 for file in "${sources[$@]}"; do
  # check if in noextract array
  if inarray "$file" "${noextract[@]}"; then
   continue # skip
  fi
  
  localname="$(getlocalfilename "$file")"
  #[ ! -e "$srcdir/$localname" ]
  if [[ ! -e "$srcdir/$localname" && -f "$startdir/$localname" ]]; then
   cd "$startdir"
   ln -s "$localname" "$srcdir"
   cd "$srcdir"
  fi
  
  if [[ ! -f "$localname" && ! -L "$localname" ]]; then
   error 1 "Could not find $localname"
  fi
  
  case "$file" in
   *tar)
    tar xf "$localname" &> /dev/null
    ret=$? ;;
   *tar.gz)
    tar xzf "$localname" &> /dev/null
    ret=$? ;;
   *tar.bz2)
    tar xjf "$localname" &> /dev/null
    ret=$? ;;
   *tar.xz)
    tar xJf "$localname" &> /dev/null
    ret=$? ;;
   *) continue
  esac
  
  if [ $ret -ne 0 ]; then
   error 1 "Error extracting $localname"
  fi
 done
}

build() {
 error 1 "No build function specified in $buildscript"
}

check() {
 return 0
}

package() {
 return 0
}

strip() {
 strippkg "$pkgdir" &> /dev/null
}

split() {
 for part in "${pkgParts[@]}"; do
  [ -d "${pkgdir}_${part}" ] && rm -rf "${pkgdir}_${part}" # delete split folder
  splitpartused "$part"
  [ $? = 1 ] && continue
  [ -d "$pkgdir-$part" ] && rm -rf "$pkgdir-$part"
  mkdir -p "$pkgdir-$part"
  [ "${part}" != "EXE" ] && mkdir -p "${pkgdir}_${part}"
 done
 
 # back up pkgdir
 cp -r "$pkgdir" "${pkgdir}-backup"
 
 # split $pkgdir
 splitpkg "$(basename "$pkgdir")" "$pkgdir" &> /dev/null
 
 # restore backup
 mv -f "$pkgdir" "${pkgdir}_EXE"
 
 mv -f "${pkgdir}-backup" "$pkgdir"
 
 shopt -s extglob
 
 # redirect output
 if [[ "$loc_EXE" != "" && "$(ls -A "${pkgdir}_EXE")" ]]; then
  cp -r "${pkgdir}_EXE/"* "${pkgdir}-${loc_EXE}/"
 fi
 if [[ "$loc_DEV" != "" && "$(ls -A "${pkgdir}_DEV")" ]]; then
  cp -r "${pkgdir}_DEV/"* "${pkgdir}-${loc_DEV}"
 fi
 if [[ "$loc_DOC" != "" && "$(ls -A "${pkgdir}_DOC")" ]]; then
  cp -r "${pkgdir}_DOC/"* "${pkgdir}-${loc_DOC}"
 fi
 if [[ "$loc_NLS" != "" && "$(ls -A "${pkgdir}_NLS")" ]]; then
  cp -r "${pkgdir}_NLS/"* "${pkgdir}-${loc_NLS}"
 fi
 
 shopt -u extglob
 
 rm -rf "${pkgdir}_"{EXE,DEV,DOC,NLS}
}

# getpetspecs()
getpetspecs() {
 local pkgsize="$(du -s -k "$pkgdir/" | cut -f 1)"
 pkgsize="${pkgsize}"
 
 local pkgdeps
 local onedep
 local onedepname
 for onedep in "${deps[@]}"; do
  #if [ "${onedep}"
  [ "$pkgdeps" != "" ] && pkgdeps="${pkgdeps},"
  pkgdeps="${pkgdeps}+${onedep}"
 done
 
 echo "${pkgfullname}|${pkgname}${pkgsplit}|$pkgver|${pkgrev}-${CARCH}|$pkgcategory|${pkgsize}K||${pkgfullname}.pet|${pkgdeps}|${pkgdesc}|"
}

compresstopkg() {
 cd "$startdir"
 local file
 local ret
 for file in "pinstall.sh" "puninstall.sh"; do
  [ -f "$file" ] && cp "$file" "$pkgdir"
 done
 
 local part
 for part in "${pkgParts[@]}"; do
  if [ "$part" != "EXE" ]; then
   pkgsplit="_${part}"
  else
   pkgsplit=""
  fi
  
  pkgfullname="${pkgname}${pkgsplit}-$pkgver-$pkgrev-$CARCH" # get package name (with split)
  rm -f "${pkgfullname}.pet" # delete old package
  
  if ! splitpartused "$part"; then # find if package part not used
   continue
  fi
  
  [ "$(ls -A "$pkgdir-${part}")" ] || continue # skip if package is empty
  # compress
  mv -f "$pkgdir-${part}" "$pkgfullname"
  echo "$(getpetspecs)" > "$pkgfullname/pet.specs"
  tar czf "${pkgfullname}.pet" "${pkgfullname}"
  ret=$?
  mv -f "$pkgfullname" "$pkgdir-${part}"
  
  if [ $ret -ne 0 ]; then
   error "Could not compress the package"
  fi
  
  echo -n "$(getmd5 "${pkgfullname}.pet")" >> "${pkgfullname}.pet"
 done
}

cleanup() {
 local folder
 for folder in 'src' 'pkg' 'pkg-EXE' 'pkg-DEV' 'pkg-DOC' 'pkg-NLS'; do
  [ -d "$folder" ] && rm -rf "$folder"
 done
}

help() {
 echo "makepuppypkg [options]"
 echo "Compiles a program into a package using a $buildscript"
 cat << HERE_EOF
Options:
    -g --generate | generate md5 sums of the files in md5sums(), then exit
    -h --help     | display this help
HERE_EOF
}

### END FUNCTIONS ###

### VARIABLES ###
#default flags
MAKEFLAGS="-j$(($(grep -c ^processor /proc/cpuinfo)+1))"
LDFLAGS="-Wl,-O1,--sort-common,--as-needed,-z,relro,--hash-style=gnu"
CARCH="$(uname -m)"
case "$CARCH" in
 i?86)
  #CARCH="$(uname -m)"
  CHOST="${CARCH}-puppy-linux-gnu"
  CFLAGS="-march=${CARCH} -mtune=generic -pipe -fstack-protector --param=ssp-buffer-size=4 -D_FORTIFY_SOURCE=2"
  CXXFLAGS="${CFLAGS}" ;;
 x86_64)
  #CARCH="x86_64"
  CHOST="x86_64-puppy-linux-gnu"
  CFLAGS="-march=x86-64 -mtune=generic -Os -pipe -fstack-protector --param=ssp-buffer-size=4 -D_FORTIFY_SOURCE=2"
  CXXFLAGS="${CFLAGS}" ;;
esac
loc_EXE='EXE'
loc_DEV='DEV'
loc_DOC='DOC'
loc_NLS='NLS'

# include makepuppypkg.conf
if [ -f makepuppypkg.conf ]; then
 . ./makepuppypkg.conf
elif [ -f ~/.makepuppypkg.conf ]; then
 . ~/.makepuppypkg.conf
elif [ -f /etc/makepuppypkg.conf ]; then
 . /etc/makepuppypkg.conf
else
 error 1 "Could not find makepuppypkg.conf"
fi

# need CARCH and CHOST
[[ "$CARCH" = "" ]] && echo "Could not find CARCH. Please define it in makepuppypkg.conf"
[[ "$CHOST" = "" ]] && echo "Could not find CHOST. Please define it in makepuppypkg.conf"

pkgParts=( 'EXE' 'DEV' 'DOC' 'NLS' )

##default buildoptions
#BUILDOPTIONS=(-deletesrcs deletesrc deletepkg)
#OPTIONS=(+strip)

startdir="$PWD"

srcdir="$startdir/src"
[ -d "$srcdir" ] && rm -rf "$srcdir"
mkdir -p "$srcdir"

pkgdir="$startdir/pkg"
[ -d "$pkgdir" ] && rm -rf "$pkgdir"
mkdir -p "$pkgdir"

### END VARIABLES ###

### MAIN CODE ###

GENMD5=0

while [[ $1 ]]; do
 case "$1" in
  -g|--generate) GENMD5=1 ;;
  -h|--help) help
   exit 0 ;;
 esac
done

if [ ! -f $buildscript ]; then
 error 1 "Could not find $buildscript"
fi

. "./$buildscript"

if [ $GENMD5 -eq 1 ]; then
 echo "$(generatemd5)" >> $buildscript
 exit 0
fi

echo "Get:"
getSources

echo "Extract:"
extractSources

export CFLAGS CXXFLAGS LDFLAGS MAKEFLAGS CHOST # export flags

echo "Build:"
build

echo "Check:"
check

echo "Package:"
package

echo "Strip:"
strip

echo "Split:"
split

echo "Compress:"
compresstopkg

echo "Clean:"
cleanup

exit 0

### END MAIN CODE ###
